import React, { useMemo, useState } from "react";

// util: generate ids
const uid = () => Math.random().toString(36).slice(2, 9);

// util: seeded shuffle (deterministic for same seed)
export function seededShuffle(arr, seed) {
  if (!seed) return [...arr];
  let s = 0;
  for (let i = 0; i < seed.length; i++) {
    s = (s * 31 + seed.charCodeAt(i)) >>> 0;
  }
  function rand() {
    s = (1664525 * s + 1013904223) >>> 0;
    return s / 2 ** 32;
  }
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(rand() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// Parse lines like: "12 John Doe" or "7.5 - Jane Smith" or just "Carlos"
// Numbers are ignored. Everyone starts at score 5. Nat defaults to NA.
export function parseListIgnoreNumbers(text) {
  const lines = text.split(/\r?\n/);
  const out = [];
  for (let raw of lines) {
    const line = raw.trim();
    if (!line) continue;
    let name = line.replace(/^\s*\d+(?:[.,]\d+)?\s*(?:[-,:\t ]+)?\s*/i, "").trim();
    name = name.replace(/\./g, "").trim();
    if (!name) continue;
    if (!/[A-Za-zÀ-ÖØ-öø-ÿ]/.test(name)) continue;
    out.push({ id: uid(), name, score: 5, nat: "NA", pos1: "", pos2: "" });
  }
  return out;
}

// build clipboard text for teams (one big block)
// rules:
// - for each team: "Team N"
// - if ANY player in that team has a position -> header "Name,Pos" and each line is name or name,pos
// - if NO players in that team have a position -> header "Name" and each line is just name
export function buildClipboardTeams(teams) {
  const lines = [];
  (teams || []).forEach((t, idx) => {
    lines.push(`Team ${idx + 1}`);
    const members = t.members || [];
    const hasAnyPos = members.some(
      (m) => (m.pos1 && m.pos1.trim()) || (m.pos2 && m.pos2.trim())
    );
    if (hasAnyPos) {
      lines.push("Name,Pos");
      members.forEach((m) => {
        const pos = (m.pos1 && m.pos1.trim()) ? m.pos1.trim() : "";
        if (pos) {
          lines.push(`${m.name},${pos}`);
        } else {
          lines.push(m.name);
        }
      });
    } else {
      lines.push("Name");
      members.forEach((m) => {
        lines.push(m.name);
      });
    }
    lines.push("");
  });
  return lines.join("\n");
}

// basic runtime tests (will just log in browser devtools)
if (typeof console !== "undefined") {
  const p = parseListIgnoreNumbers(
    "12. Luis Miguel\n7.5 - Jane Smith.\n...\n  33 Carlos"
  );
  console.assert(p.length === 3, "parseListIgnoreNumbers should keep 3 valid names");
  console.assert(p[0].name === "Luis Miguel", "first name cleaned");
  const sh = seededShuffle([1, 2, 3, 4], "x");
  console.assert(
    Array.isArray(sh) && sh.length === 4,
    "seededShuffle returns array"
  );
  // clipboard base format
  const clip = buildClipboardTeams([
    { name: "Team 1", members: [{ name: "A", pos1: "D" }, { name: "B", pos1: "M" }] },
    { name: "Team 2", members: [{ name: "C", pos1: "F" }] },
  ]);
  console.assert(
    clip.includes("Team 1") &&
      clip.includes("Name,Pos") &&
      clip.includes("A,D"),
    "clipboard base format ok"
  );
  // clipboard no-pos format
  const clipNoPos = buildClipboardTeams([
    { name: "Team 3", members: [{ name: "X", pos1: "" }, { name: "Y", pos1: "" }] },
  ]);
  console.assert(
    clipNoPos.includes("Team 3") &&
      clipNoPos.includes("Name\nX\nY"),
    "clipboard no-pos format ok"
  );
}

export default function App() {
  const [players, setPlayers] = useState([]);
  const [numTeams, setNumTeams] = useState(2);
  const [teamSize, setTeamSize] = useState(5);
  const [seed, setSeed] = useState("");
  const [sameNatWeight, setSameNatWeight] = useState(1.0);
  const [posWeight, setPosWeight] = useState(2.0);
  const [scoreWeight, setScoreWeight] = useState(1.0);
  const [pasteText, setPasteText] = useState("");
  const [appendMode, setAppendMode] = useState(false);
  const [lockedTeam, setLockedTeam] = useState(null);

  function validPlayers(rows) {
    return rows
      .map((r) => {
        const nat = (r.nat || "").trim();
        return {
          ...r,
          name: (r.name || "").trim(),
          nat: nat ? nat : "NA",
          pos1: (r.pos1 || "").trim(),
          pos2: (r.pos2 || "").trim(),
          score: Number.isFinite(Number(r.score)) ? Number(r.score) : 5,
        };
      })
      .filter((r) => r.name);
  }

  function allPositions(rows) {
    const set = new Set();
    rows.forEach((r) => {
      if (r.pos1) set.add(r.pos1);
      if (r.pos2) set.add(r.pos2);
    });
    return Array.from(set).sort();
  }

  const result = useMemo(() => {
    const rows = validPlayers(players);
    const needed = numTeams * teamSize;
    if (numTeams < 1 || teamSize < 1)
      return {
        error: "Set teams and size.",
        teams: [],
        targets: [],
        allPos: [],
        bench: [],
        used: 0,
      };
    if (rows.length < needed)
      return {
        error: `Need ${needed} players, have ${rows.length}.`,
        teams: [],
        targets: [],
        allPos: [],
        bench: [],
        used: 0,
      };

    const orderedAll = seededShuffle(
      [...rows].sort(
        (a, b) => b.score - a.score || a.name.localeCompare(b.name)
      ),
      seed
    );
    const pool = orderedAll.slice(0, needed);
    const bench = orderedAll.slice(needed);

    const allPos = allPositions(pool);
    const posCounts = Object.fromEntries(allPos.map((p) => [p, 0]));
    pool.forEach((r) => {
      if (r.pos1) posCounts[r.pos1] = (posCounts[r.pos1] || 0) + 1;
    });
    const targets = Array.from({ length: numTeams }, () => ({}));
    for (const pos of allPos) {
      const total = posCounts[pos] || 0;
      const q = Math.floor(total / numTeams);
      let rem = total % numTeams;
      for (let t = 0; t < numTeams; t++) targets[t][pos] = q + (t < rem ? 1 : 0);
    }

    const teams = Array.from({ length: numTeams }, (_, i) => ({
      name: `Team ${i + 1}`,
      members: [],
      score: 0,
      pos: {},
      nat: {},
    }));
    const avgScore = pool.reduce((s, r) => s + r.score, 0) / numTeams;

    const activeLock = lockedTeam && lockedTeam.index < numTeams ? lockedTeam : null;
    const lockedIdSet = new Set(activeLock ? activeLock.memberIds : []);
    const assignedLocked = new Set();

    if (activeLock) {
      const t = teams[activeLock.index];
      for (const r of pool) {
        if (!lockedIdSet.has(r.id)) continue;
        if (t.members.length >= teamSize) continue;
        t.members.push(r);
        t.score += r.score;
        if (r.pos1) t.pos[r.pos1] = (t.pos[r.pos1] || 0) + 1;
        if (r.pos2) t.pos[r.pos2] = (t.pos[r.pos2] || 0);
        if (r.nat) t.nat[r.nat] = (t.nat[r.nat] || 0) + 1;
        assignedLocked.add(r.id);
      }
    }

    function teamCost(ti, r) {
      const t = teams[ti];
      if (t.members.length >= teamSize) return 1e9;
      const scoreBalance = Math.abs(t.score + r.score - avgScore) * scoreWeight;
      let deficit = 0;
      const positions = [r.pos1, r.pos2].filter(Boolean);
      if (positions.length) {
        let best = 0;
        for (const p of positions) {
          const have = t.pos[p] || 0;
          const need = targets[ti][p] || 0;
          const d = have < need ? need - have - 0.5 : 0;
          if (d > best) best = d;
        }
        deficit = best * posWeight;
      }
      const natCount = r.nat ? t.nat[r.nat] || 0 : 0;
      const natCohesion = -sameNatWeight * natCount;
      return scoreBalance + deficit + natCohesion;
    }

    for (const r of pool) {
      if (assignedLocked.has(r.id)) continue;
      let bestI = 0,
        bestC = Infinity;
      for (let ti = 0; ti < numTeams; ti++) {
        const c = teamCost(ti, r);
        if (
          c < bestC ||
          (c === bestC && teams[ti].members.length < teams[bestI].members.length)
        ) {
          bestI = ti;
          bestC = c;
        }
      }
      const t = teams[bestI];
      t.members.push(r);
      t.score += r.score;
      if (r.pos1) t.pos[r.pos1] = (t.pos[r.pos1] || 0) + 1;
      if (r.pos2) t.pos[r.pos2] = (t.pos[r.pos2] || 0);
      if (r.nat) t.nat[r.nat] = (t.nat[r.nat] || 0) + 1;
    }

    teams.forEach((t) =>
      t.members.sort(
        (a, b) => (a.pos1 || "").localeCompare(b.pos1 || "") || a.name.localeCompare(b.name)
      )
    );

    return { teams, targets, allPos, bench, used: pool.length, error: undefined };
  }, [players, numTeams, teamSize, seed, sameNatWeight, posWeight, scoreWeight, lockedTeam]);

  function setSamples() {
    const seedData = [
      ["Carlos", 5, "col", "f", ""],
      ["Coco", 5, "ar", "d", ""],
      ["franco", 5, "ch", "d", ""],
      ["Luis Miguel", 5, "col", "f", ""],
      ["Mohamed Eid", 5, "eg", "m", ""],
      ["pol", 5, "es", "m", ""],
      ["JP", 5, "ar", "f", ""],
      ["Clem", 5, "fr", "f", ""],
      ["Martin", 5, "ar", "d", ""],
      ["Facu", 5, "ar", "m", ""],
      ["Tincho", 5, "ar", "d", ""],
      ["Ismail", 5, "nl", "d", ""],
      ["Jannick", 5, "nl", "f", ""],
      ["Edgar", 5, "col", "d", ""],
      ["Meander", 5, "nl", "f", "m"],
      ["Mateo", 5, "ar", "m", "f"],
      ["Damo", 5, "ar", "d", ""],
      ["Dimitris", 5, "gr", "f", ""],
    ];
    setPlayers(
      seedData.map(([name, score, nat, pos1, pos2]) => ({
        id: uid(),
        name,
        score,
        nat,
        pos1,
        pos2,
      }))
    );
    setLockedTeam(null);
  }

  function applyPaste() {
    const parsed = parseListIgnoreNumbers(pasteText);
    if (parsed.length === 0) {
      alert("No valid lines found. Example: '12 John Doe' or just 'John Doe'");
      return;
    }
    setPlayers((p) => (appendMode ? [...p, ...parsed] : parsed));
    setLockedTeam(null);
  }

  function toggleLockTeam(index) {
    if (!result.teams || !result.teams[index]) return;
    if (lockedTeam && lockedTeam.index === index) {
      setLockedTeam(null);
    } else {
      setLockedTeam({ index, memberIds: result.teams[index].members.map((m) => m.id) });
    }
  }

  function copyTeamsToClipboard() {
    const text = buildClipboardTeams(result.teams || []);
    if (!text.trim()) {
      alert("No teams to export.");
      return;
    }
    if (typeof navigator !== "undefined" && navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).catch(() => {
        window.prompt("Copy the teams below:", text);
      });
    } else {
      window.prompt("Copy the teams below:", text);
    }
  }

  // split teams into up to two rows
  const teams = result.teams || [];
  const needsTwoRows = teams.length > 3;
  const upper = needsTwoRows ? teams.slice(0, Math.ceil(teams.length / 2)) : teams;
  const lower = needsTwoRows ? teams.slice(Math.ceil(teams.length / 2)) : [];

  return (
    <div className="mx-auto max-w-7xl p-6 space-y-6">
      <header className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Balanced Team Builder</h1>
        <div className="flex gap-2">
          <button className="rounded-2xl border px-4 py-2" onClick={setSamples}>
            Fill sample data
          </button>
          <button className="rounded-2xl border px-4 py-2" onClick={() => { setPlayers([]); setLockedTeam(null); }}>
            Clear
          </button>
        </div>
      </header>

      {/* core settings */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4 bg-white p-4 rounded-2xl shadow">
        <label className="flex flex-col gap-1">
          <span className="text-sm text-gray-600">Teams</span>
          <input
            type="number"
            min="1"
            value={numTeams}
            onChange={(e) => setNumTeams(Math.max(1, Number(e.target.value)))}
            className="rounded-xl border px-3 py-2"
          />
        </label>
        <label className="flex flex-col gap-1">
          <span className="text-sm text-gray-600">Team size</span>
          <input
            type="number"
            min="1"
            value={teamSize}
            onChange={(e) => setTeamSize(Math.max(1, Number(e.target.value)))}
            className="rounded-xl border px-3 py-2"
          />
        </label>
      </div>

      {/* paste list panel */}
      <div className="bg-white p-4 rounded-2xl shadow space-y-2">
        <div className="flex items-center justify-between">
          <div className="font-semibold">
            Paste names: number is ignored. Everyone starts at score 5. Nat = NA.
          </div>
          <label className="flex items-center gap-2 text-sm">
            <input
              type="checkbox"
              checked={appendMode}
              onChange={(e) => setAppendMode(e.target.checked)}
            />
            Append to existing
          </label>
        </div>
        <textarea
          className="w-full h-32 rounded-xl border p-2 font-mono"
          value={pasteText}
          onChange={(e) => setPasteText(e.target.value)}
        />
        <div className="flex gap-2">
          <button className="rounded-2xl bg-green-600 text-white px-4 py-2" onClick={applyPaste}>
            Parse & Add
          </button>
          <button className="rounded-2xl border px-4 py-2" onClick={() => setPasteText("")}>
            Clear text
          </button>
        </div>
      </div>

      {/* player table */}
      <div className="overflow-hidden rounded-2xl bg-white shadow">
        <table className="min-w-full">
          <thead className="bg-gray-100 text-left text-sm text-gray-700">
            <tr>
              <th className="px-3 py-2">Name</th>
              <th className="px-3 py-2">Score</th>
              <th className="px-3 py-2">Nationality</th>
              <th className="px-3 py-2">Primary Pos</th>
              <th className="px-3 py-2">Secondary Pos</th>
              <th className="px-3 py-2"></th>
            </tr>
          </thead>
          <tbody>
            {[...players]
              .sort(
                (a, b) =>
                  (a.pos1 || "").localeCompare(b.pos1 || "") ||
                  a.name.localeCompare(b.name)
              )
              .map((r) => (
                <tr key={r.id} className="border-t">
                  <td className="px-3 py-2">
                    <input
                      className="w-full rounded-lg border px-2 py-1"
                      value={r.name}
                      placeholder="Player"
                      onChange={(e) =>
                        setPlayers((p) =>
                          p.map((rr) =>
                            rr.id === r.id ? { ...rr, name: e.target.value } : rr
                          )
                        )
                      }
                    />
                  </td>
                  <td className="px-3 py-2">
                    <input
                      type="number"
                      className="w-24 rounded-lg border px-2 py-1"
                      value={r.score}
                      onChange={(e) =>
                        setPlayers((p) =>
                          p.map((rr) =>
                            rr.id === r.id ? { ...rr, score: Number(e.target.value) } : rr
                          )
                        )
                      }
                    />
                  </td>
                  <td className="px-3 py-2">
                    <input
                      className="w-28 rounded-lg border px-2 py-1"
                      value={r.nat || "NA"}
                      placeholder="e.g. NL"
                      onChange={(e) =>
                        setPlayers((p) =>
                          p.map((rr) =>
                            rr.id === r.id ? { ...rr, nat: e.target.value } : rr
                          )
                        )
                      }
                    />
                  </td>
                  <td className="px-3 py-2">
                    <input
                      className="w-24 rounded-lg border px-2 py-1"
                      value={r.pos1 || ""}
                      placeholder="e.g. D"
                      onChange={(e) =>
                        setPlayers((p) =>
                          p.map((rr) =>
                            rr.id === r.id ? { ...rr, pos1: e.target.value } : rr
                          )
                        )
                      }
                    />
                  </td>
                  <td className="px-3 py-2">
                    <input
                      className="w-28 rounded-lg border px-2 py-1"
                      value={r.pos2 || ""}
                      placeholder="optional"
                      onChange={(e) =>
                        setPlayers((p) =>
                          p.map((rr) =>
                            rr.id === r.id ? { ...rr, pos2: e.target.value } : rr
                          )
                        )
                      }
                    />
                  </td>
                  <td className="px-3 py-2 text-right">
                    <button
                      className="rounded-lg border px-2 py-1 text-sm"
                      onClick={() =>
                        setPlayers((p) => p.filter((rr) => rr.id !== r.id))
                      }
                    >
                      Delete
                    </button>
                  </td>
                </tr>
              ))}
            <tr>
              <td colSpan="6" className="px-3 py-3">
                <div className="flex items-center justify-between gap-2">
                  <button
                    className="rounded-2xl border px-4 py-2 text-sm"
                    onClick={() => {
                      setPlayers([]);
                      setLockedTeam(null);
                    }}
                  >
                    Delete all players
                  </button>
                  <button
                    className="rounded-2xl bg-black px-4 py-2 text-white"
                    onClick={() =>
                      setPlayers((p) => [
                        ...p,
                        { id: uid(), name: "", score: 5, nat: "NA", pos1: "", pos2: "" },
                      ])
                    }
                  >
                    + Add player
                  </button>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>

      {/* shuffle and error info after full player list */}
      <div className="flex items-center justify-between gap-4">
        <div className="flex gap-2">
          <button
            className="rounded-2xl bg-indigo-600 text-white px-4 py-2"
            onClick={() => setSeed(String(Date.now()))}
          >
            Re-shuffle
          </button>
          <button
            className="rounded-2xl border px-4 py-2"
            onClick={copyTeamsToClipboard}
          >
            Copy teams
          </button>
        </div>
        {result.error && <div className="text-sm text-red-600">{result.error}</div>}
      </div>

      {/* importance + summary after player list */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div className="bg-white p-4 rounded-2xl shadow space-y-3">
          <div className="font-semibold">Importance</div>
          <div className="space-y-2">
            <label className="block text-sm">
              Nationality cohesion: {sameNatWeight.toFixed(1)}
              <input
                type="range"
                min="0"
                max="5"
                step="0.1"
                value={sameNatWeight}
                onChange={(e) => setSameNatWeight(Number(e.target.value))}
                className="w-full"
              />
            </label>
            <label className="block text-sm">
              Position distribution: {posWeight.toFixed(1)}
              <input
                type="range"
                min="0"
                max="5"
                step="0.1"
                value={posWeight}
                onChange={(e) => setPosWeight(Number(e.target.value))}
                className="w-full"
              />
            </label>
            <label className="block text-sm">
              Score balance: {scoreWeight.toFixed(1)}
              <input
                type="range"
                min="0"
                max="5"
                step="0.1"
                value={scoreWeight}
                onChange={(e) => setScoreWeight(Number(e.target.value))}
                className="w-full"
              />
            </label>
          </div>
        </div>

        <div className="md:col-span-2 bg-white p-4 rounded-2xl shadow">
          <div className="font-semibold mb-2">Summary</div>
          <div className="text-sm text-gray-700">Players used: {result.used}</div>
          {result.allPos.length > 0 && (
            <div className="overflow-auto mt-2">
              <table className="min-w-full text-sm">
                <thead className="bg-gray-100">
                  <tr>
                    <th className="px-2 py-1 text-left">Team</th>
                    {result.allPos.map((p) => (
                      <th key={p} className="px-2 py-1 text-left">
                        {p}
                      </th>
                    ))}
                  </tr>
                </thead>
                <tbody>
                  {result.targets.map((row, i) => (
                    <tr key={i} className="border-t">
                      <td className="px-2 py-1">Team {i + 1}</td>
                      {result.allPos.map((p) => (
                        <td key={p} className="px-2 py-1">
                          {row[p] || 0}
                        </td>
                      ))}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </div>

      {/* teams spanning full width, 1 or 2 rows */}
      {teams.length > 0 && (
        <div className="space-y-4">
          <div className="flex gap-4 w-full">
            {upper.map((t, i) => (
              <div
                key={t.name}
                style={{ flex: `0 0 ${100 / upper.length}%` }}
                className="bg-white p-4 rounded-2xl shadow"
              >
                <div className="mb-2 flex items-center justify-between gap-2">
                  <div>
                    <div className="text-lg font-semibold flex items-center gap-2">
                      {t.name}
                      {lockedTeam?.index === i && (
                        <span className="text-xs bg-red-100 text-red-700 px-2 py-0.5 rounded-full">
                          Held
                        </span>
                      )}
                    </div>
                    <div className="text-sm text-gray-700">
                      Total score: {t.score.toFixed(1)}
                    </div>
                  </div>
                  <button
                    className={`rounded-xl px-3 py-1 text-xs border ${
                      lockedTeam?.index === i
                        ? "bg-red-500 text-white border-red-500"
                        : "bg-white text-gray-700"
                    }`}
                    onClick={() => toggleLockTeam(i)}
                  >
                    {lockedTeam?.index === i ? "Release" : "Hold"}
                  </button>
                </div>
                <div className="overflow-hidden rounded-xl border">
                  <table className="min-w-full text-sm">
                    <thead className="bg-gray-100 text-left">
                      <tr>
                        <th className="px-3 py-2">Name</th>
                        <th className="px-3 py-2">Nationality</th>
                        <th className="px-3 py-2">Pos1</th>
                        <th className="px-3 py-2">Pos2</th>
                      </tr>
                    </thead>
                    <tbody>
                      {t.members.map((m) => (
                        <tr key={m.id} className="border-t">
                          <td className="px-3 py-2">{m.name}</td>
                          <td className="px-3 py-2">{m.nat || "NA"}</td>
                          <td className="px-3 py-2">{m.pos1 || "—"}</td>
                          <td className="px-3 py-2">{m.pos2 || "—"}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
                <div className="mt-2 text-xs text-gray-600">
                  Pos mix: {Object.entries(t.pos).map(([p, c]) => `${p}:${c}`).join(" ") || "—"}
                </div>
                <div className="mt-1 text-xs text-gray-600">
                  Nationality mix: {Object.entries(t.nat).map(([n, c]) => `${n}:${c}`).join(" ") || "—"}
                </div>
              </div>
            ))}
          </div>
          {needsTwoRows && lower.length > 0 && (
            <div className="flex gap-4 w-full">
              {lower.map((t, idx) => {
                const realIndex = upper.length + idx;
                return (
                  <div
                    key={t.name}
                    style={{ flex: `0 0 ${100 / lower.length}%` }}
                    className="bg-white p-4 rounded-2xl shadow"
                  >
                    <div className="mb-2 flex items-center justify-between gap-2">
                      <div>
                        <div className="text-lg font-semibold flex items-center gap-2">
                          {t.name}
                          {lockedTeam?.index === realIndex && (
                            <span className="text-xs bg-red-100 text-red-700 px-2 py-0.5 rounded-full">
                              Held
                            </span>
                          )}
                        </div>
                        <div className="text-sm text-gray-700">
                          Total score: {t.score.toFixed(1)}
                        </div>
                      </div>
                      <button
                        className={`rounded-xl px-3 py-1 text-xs border ${
                          lockedTeam?.index === realIndex
                            ? "bg-red-500 text-white border-red-500"
                            : "bg-white text-gray-700"
                        }`}
                        onClick={() => toggleLockTeam(realIndex)}
                      >
                        {lockedTeam?.index === realIndex ? "Release" : "Hold"}
                      </button>
                    </div>
                    <div className="overflow-hidden rounded-xl border">
                      <table className="min-w-full text-sm">
                        <thead className="bg-gray-100 text-left">
                          <tr>
                            <th className="px-3 py-2">Name</th>
                            <th className="px-3 py-2">Nationality</th>
                            <th className="px-3 py-2">Pos1</th>
                            <th className="px-3 py-2">Pos2</th>
                          </tr>
                        </thead>
                        <tbody>
                          {t.members.map((m) => (
                            <tr key={m.id} className="border-t">
                              <td className="px-3 py-2">{m.name}</td>
                              <td className="px-3 py-2">{m.nat || "NA"}</td>
                              <td className="px-3 py-2">{m.pos1 || "—"}</td>
                              <td className="px-3 py-2">{m.pos2 || "—"}</td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                    <div className="mt-2 text-xs text-gray-600">
                      Pos mix: {Object.entries(t.pos).map(([p, c]) => `${p}:${c}`).join(" ") || "—"}
                    </div>
                    <div className="mt-1 text-xs text-gray-600">
                      Nationality mix: {Object.entries(t.nat).map(([n, c]) => `${n}:${c}`).join(" ") || "—"}
                    </div>
                  </div>
                );
              })}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

// Methodology: 1) clean and normalize input players (strip leading numbers, drop dots, default nationality to "NA", force numeric score). 2) derive needed players from numTeams * teamSize and sort by score then name. 3) compute per-position global counts and split them evenly across teams as targets. 4) assign any locked team first, preserving member ids. 5) assign remaining players greedily to the team with the lowest cost, where cost = score imbalance * scoreWeight + position deficit * posWeight - same-nationality * sameNatWeight. 6) render teams in one or two rows so all panels span the width.
